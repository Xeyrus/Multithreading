*** Problems with locks:
1) Deadlocks
2) Slow critical section
3) Priority inversion : Low Priority thread(Doc saver) acquires lock and is preempted out(scheduled out)
                        High priority thread can't progress cuz of low priority thread is not schduled to release the lock
4) Kill Tolerance :  Thread dies, gets interrupted or forgets to release a lock.
5) Performance overhead


*** Why needed locks:
1) Multiple threads accessing shared resource.
2) Atleast one thread is modifying the shared resource.
3) Non-atomic modification

*** lock free solution:
1) utilize operations which are guaranteed to be one hardware operation
2) A single harware operation is-
    - Atomic by definition
    - Thread safe

*** Atomic operations:
1) Read/assignment on all primitive types(except long and double)
2) Read/assignment on all references.
3) Volatile read/write on all primitive types.(including long and double)

*** Avoid data races:
Read/assignment on all volatile primitive types and references

*** Atomic classes: java.util.concurrent.atomic package
- Internally uses Unsafe class which provides access to low level, native methods (perform atomic operations)